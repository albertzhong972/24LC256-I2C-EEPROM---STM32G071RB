/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32g071xx.h"
#include "uart.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


uint8_t readData[10]; // data received from I2C will be stored here



void GPIO_Config(void)
{
	RCC->IOPENR |= (1 << 2); //enable Port C
	GPIOC->MODER &= ~(3 << 26);	//set PC13 as input
}

void I2C1_Config(void)
{
	//Setup GPIO pins
	RCC->IOPENR |= (1 << 1); //enable Port B
	RCC->APBENR1 |= (1 << 21); //enable I2C1 clock

	GPIOB->MODER &= ~(1 << 16);	//Set PB8 to use alternate function (I2C1_SCL)
	GPIOB->MODER &= ~(1 << 18);	//Set PB9 to use alternate function (I2C1_SDA)

	GPIOB->AFR[1] |= (6 << 0); //Use AF6 on PB8 (I2C1_SCL)
	GPIOB->AFR[1] |= (6 << 4); //Use AF6 on PB9 (I2C1_SDA)

	I2C1->TIMINGR = 0x00303D5B; //100KHz speed, value calculated by CubeMX
	I2C1->CR1 |= (1 << 0); //Peripheral enable

	//7-bit addressing mode is default

}

void I2C1_WriteString(uint8_t device_address, uint8_t memory_address, uint8_t* data)
{
	uint8_t * s = data;
	I2C1->CR2 |= (device_address << 0); //slave address
	I2C1->CR2 &= ~(1 << 10); //master requests a write transfer
	I2C1->CR2 |= (12 << 16); //transfer n bytes
	I2C1->CR2 |= (1 << 13); //Start

	while(!(I2C1->ISR & 1)); //wait for TXE = 1
	I2C1->TXDR = 0;

	while(!(I2C1->ISR & 1)); //wait for TXE = 1
	I2C1->TXDR = memory_address;

	while(*s)
	{
		while(!(I2C1->ISR & 1)); //wait for TXE = 1
		I2C1->TXDR = *s;
		s++;
	}


	while(!(I2C1->ISR & 1)); //wait for TXE = 1, to make sure last byte is sent
	I2C1->CR2 |= (1 << 14); //Stop

}

void I2C1_ReadString(uint8_t device_address, uint8_t memory_address, uint8_t length)
{
	uint8_t *s = readData;

	I2C1->CR2 |= (device_address << 0); //slave address
	I2C1->CR2 &= ~(1 << 10); //master requests a write transfer
	I2C1->CR2 |= (length << 16); //transfer n bytes
	I2C1->CR2 |= (1 << 13); //Start

	while(!(I2C1->ISR & 1)); //wait for TXE = 1
	I2C1->TXDR = 0;

	while(!(I2C1->ISR & 1)); //wait for TXE = 1
	I2C1->TXDR = memory_address;

	while(!(I2C1->ISR & 1)); //wait for TXE = 1, to make sure last byte is sent
	I2C1->CR2 |= (1 << 14); //Stop

	I2C1->CR2 |= (1 << 10); //master requests a read transfer
	I2C1->CR2 |= (1 << 13); //Start
	//while(!(I2C1->ISR & (1 << 2))); //wait for RXNE = 1 (RXDR has something in it)
	for(int i = 0; i < length; i++)
	{
		while(!(I2C1->ISR & (1 << 2))); //wait for RXNE = 1 (RXDR has something in it)
		*s = I2C1->RXDR;
		s++;
	}

	I2C1->CR2 |= (1 << 14); //Stop


}

int main(void)
{
	UART_Config();
	GPIO_Config();
	I2C1_Config();
    /* Loop forever */
	int pressed = 0;
	uint8_t writeData[10] = "Albert";
	while(1)
	{
		if(!((GPIOC -> IDR) & 0x2000) && pressed == 0)
		{
		//I2C1_WriteString(0b10100000, 0, writeData);
		I2C1_ReadString(0b10100000, 0, 12);
		UART_SendString((char*) readData);
		pressed = 1;
		}
	}
}
